import * as vscode from "vscode";
import * as path from "path";
import * as fs from "fs/promises";
import * as TOML from "@iarna/toml";

type EntryPoint = {
  name: string;
  target: string;
  module: string;
  func: string;
};

type LastRun = {
  scriptName: string;
  target: string;
  argsLine: string;
};

const EXT_NS = "uvDebugScripts";
const LAST_RUN_KEY = "lastRun";

function splitEntryPoint(target: string): { module: string; func: string } | null {
  const idx = target.lastIndexOf(":");
  if (idx <= 0 || idx === target.length - 1) return null;
  return { module: target.slice(0, idx), func: target.slice(idx + 1) };
}

async function fileExists(p: string): Promise<boolean> {
  try {
    await fs.stat(p);
    return true;
  } catch {
    return false;
  }
}

function parseArgs(argLine: string): string[] {
  const out: string[] = [];
  let cur = "";
  let q: "'" | '"' | null = null;
  let esc = false;

  for (const ch of argLine) {
    if (esc) {
      cur += ch;
      esc = false;
      continue;
    }
    if (ch === "\\") {
      esc = true;
      continue;
    }
    if (q) {
      if (ch === q) q = null;
      else cur += ch;
      continue;
    }
    if (ch === "'" || ch === '"') {
      q = ch;
      continue;
    }
    if (/\s/.test(ch)) {
      if (cur.length) out.push(cur), (cur = "");
      continue;
    }
    cur += ch;
  }
  if (cur.length) out.push(cur);
  return out;
}

function getWorkspaceFolderOrThrow(): vscode.WorkspaceFolder {
  const wf = vscode.workspace.workspaceFolders?.[0];
  if (!wf) throw new Error("Open a folder/workspace first.");
  return wf;
}

async function readUvScripts(workspaceFolder: string): Promise<EntryPoint[]> {
  const pyprojectPath = path.join(workspaceFolder, "pyproject.toml");
  const raw = await fs.readFile(pyprojectPath, "utf8");
  const doc = TOML.parse(raw) as any;

  const scripts: Record<string, string> = doc?.project?.scripts ?? {};
  const guiScripts: Record<string, string> = doc?.project?.["gui-scripts"] ?? {};

  const entries: EntryPoint[] = [];
  for (const [name, target] of Object.entries({ ...scripts, ...guiScripts })) {
    if (typeof target !== "string") continue;
    const parts = splitEntryPoint(target);
    if (!parts) continue;
    entries.push({ name, target, module: parts.module, func: parts.func });
  }

  return entries.sort((a, b) => a.name.localeCompare(b.name));
}

async function ensureWrapper(workspaceFolder: string, ep: EntryPoint): Promise<string> {
  const vscodeDir = path.join(workspaceFolder, ".vscode");
  await fs.mkdir(vscodeDir, { recursive: true });

  const wrapperPath = path.join(vscodeDir, ".uv_debug_entry.py");
  const code = `# Auto-generated by UV Debug Scripts
import importlib

MOD = ${JSON.stringify(ep.module)}
FN = ${JSON.stringify(ep.func)}

def _run():
    m = importlib.import_module(MOD)
    f = getattr(m, FN)
    return f()

if __name__ == "__main__":
    raise SystemExit(_run())
`;

  await fs.writeFile(wrapperPath, code, "utf8");
  return wrapperPath;
}

async function resolvePythonPath(workspaceFolder: string): Promise<string | undefined> {
  const isWin = process.platform === "win32";
  const candidate = isWin
    ? path.join(workspaceFolder, ".venv", "Scripts", "python.exe")
    : path.join(workspaceFolder, ".venv", "bin", "python");

  if (await fileExists(candidate)) return candidate;
  return undefined; // let Python extension / VS Code decide
}

async function startDebug(
  wf: vscode.WorkspaceFolder,
  ep: EntryPoint,
  argsLine: string
): Promise<void> {
  const root = wf.uri.fsPath;
  const wrapper = await ensureWrapper(root, ep);
  const pythonPath = await resolvePythonPath(root);

  const cfg: vscode.DebugConfiguration = {
    type: "python",
    request: "launch",
    name: `uv: ${ep.name}`,
    program: wrapper,
    args: parseArgs(argsLine),
    console: "integratedTerminal",
    justMyCode: true,
    ...(pythonPath ? { python: pythonPath } : {})
  };

  const ok = await vscode.debug.startDebugging(wf, cfg);
  if (!ok) throw new Error("Failed to start debugging session.");
}

function renderStatusBar(
  status: vscode.StatusBarItem,
  last: LastRun | undefined
): void {
  if (!last) {
    status.text = "$(play) uv: pick script";
    status.tooltip = "Pick a uv [project.scripts] entry and debug it";
    status.command = `${EXT_NS}.debugScript`;
  } else {
    status.text = `$(debug-alt) uv: ${last.scriptName}`;
    status.tooltip = `Debug last: ${last.scriptName}\nArgs: ${last.argsLine || "(none)"}`;
    status.command = `${EXT_NS}.debugLastScript`;
  }
  status.show();
}

async function setLastRun(
  context: vscode.ExtensionContext,
  status: vscode.StatusBarItem,
  last: LastRun
): Promise<void> {
  await context.workspaceState.update(LAST_RUN_KEY, last);
  renderStatusBar(status, last);
}

async function pickAndDebug(
  context: vscode.ExtensionContext,
  status: vscode.StatusBarItem
): Promise<void> {
  const wf = getWorkspaceFolderOrThrow();
  const root = wf.uri.fsPath;

  const scripts = await readUvScripts(root);
  if (!scripts.length) {
    vscode.window.showWarningMessage(
      "No [project.scripts] or [project.gui-scripts] found in pyproject.toml."
    );
    return;
  }

  const picked = await vscode.window.showQuickPick(
    scripts.map((s) => ({ label: s.name, description: s.target, s })),
    { title: "UV: Debug which script?" }
  );
  if (!picked) return;

  const argsLine = await vscode.window.showInputBox({
    title: `Args for ${picked.s.name}`,
    prompt: "Optional arguments (e.g. --foo 1 --bar \"hi\")",
    placeHolder: ""
  });
  if (argsLine === undefined) return;

  await startDebug(wf, picked.s, argsLine);
  await setLastRun(context, status, {
    scriptName: picked.s.name,
    target: picked.s.target,
    argsLine
  });
}

async function debugLast(
  context: vscode.ExtensionContext,
  status: vscode.StatusBarItem
): Promise<void> {
  const wf = getWorkspaceFolderOrThrow();
  const root = wf.uri.fsPath;

  const last = context.workspaceState.get<LastRun>(LAST_RUN_KEY);
  if (!last) {
    // Button behavior: if no last, act like “pick”
    await pickAndDebug(context, status);
    return;
  }

  const scripts = await readUvScripts(root);
  const ep = scripts.find((s) => s.name === last.scriptName && s.target === last.target);

  if (!ep) {
    vscode.window.showWarningMessage(
      `Last script not found in pyproject.toml: ${last.scriptName} = ${last.target}`
    );
    await pickAndDebug(context, status);
    return;
  }

  const argsLine = await vscode.window.showInputBox({
    title: `Args for ${ep.name}`,
    prompt: "Enter args (edit or reuse last)",
    value: last.argsLine
  });
  if (argsLine === undefined) return;

  await startDebug(wf, ep, argsLine);
  await setLastRun(context, status, {
    scriptName: ep.name,
    target: ep.target,
    argsLine
  });
}

export function activate(context: vscode.ExtensionContext) {
  const status = vscode.window.createStatusBarItem(
    vscode.StatusBarAlignment.Left,
    100
  );
  context.subscriptions.push(status);

  // Initialize status bar immediately
  const last = context.workspaceState.get<LastRun>(LAST_RUN_KEY);
  renderStatusBar(status, last);

  // Optional nicety: if pyproject changes, keep status bar visible and sane
  const pyprojectWatcher = vscode.workspace.createFileSystemWatcher("**/pyproject.toml");
  context.subscriptions.push(pyprojectWatcher);

  const refresh = () => {
    const l = context.workspaceState.get<LastRun>(LAST_RUN_KEY);
    renderStatusBar(status, l);
  };
  pyprojectWatcher.onDidChange(refresh, null, context.subscriptions);
  pyprojectWatcher.onDidCreate(refresh, null, context.subscriptions);
  pyprojectWatcher.onDidDelete(refresh, null, context.subscriptions);

  context.subscriptions.push(
    vscode.commands.registerCommand(`${EXT_NS}.debugScript`, async () => {
      try {
        await pickAndDebug(context, status);
      } catch (e: any) {
        vscode.window.showErrorMessage(e?.message ?? String(e));
      }
    })
  );

  context.subscriptions.push(
    vscode.commands.registerCommand(`${EXT_NS}.debugLastScript`, async () => {
      try {
        await debugLast(context, status);
      } catch (e: any) {
        vscode.window.showErrorMessage(e?.message ?? String(e));
      }
    })
  );
}

export function deactivate() {}