import * as vscode from "vscode";
import * as path from "path";
import * as fs from "fs/promises";
import * as TOML from "@iarna/toml";

type EntryPoint = {
  name: string;
  target: string;
  module: string;
  func: string;
};

type LastRun = {
  scriptName: string;
  target: string;
  argsLine: string;
};

const EXT_NS = "uvDebugScripts";
const LAST_RUN_KEY_PREFIX = "lastRun:";
const LAST_WF_KEY = "lastWorkspaceFolder";

// ---------- small utilities ----------

function workspaceKey(wf: vscode.WorkspaceFolder): string {
  return wf.uri.toString();
}

function wfFromKey(id: string | undefined): vscode.WorkspaceFolder | undefined {
  if (!id) return undefined;
  return (vscode.workspace.workspaceFolders ?? []).find((w) => workspaceKey(w) === id);
}

async function fileExists(p: string): Promise<boolean> {
  try {
    await fs.stat(p);
    return true;
  } catch {
    return false;
  }
}

async function hasVenv(root: string): Promise<boolean> {
  const isWin = process.platform === "win32";
  const py = isWin
    ? path.join(root, ".venv", "Scripts", "python.exe")
    : path.join(root, ".venv", "bin", "python");
  return fileExists(py);
}

function splitEntryPoint(target: string): { module: string; func: string } | null {
  const idx = target.lastIndexOf(":");
  if (idx <= 0 || idx === target.length - 1) return null;
  return { module: target.slice(0, idx), func: target.slice(idx + 1) };
}

function parseArgs(argLine: string): string[] {
  // Minimal shell-ish parsing: quotes + backslashes
  const out: string[] = [];
  let cur = "";
  let q: "'" | '"' | null = null;
  let esc = false;

  for (const ch of argLine) {
    if (esc) {
      cur += ch;
      esc = false;
      continue;
    }
    if (ch === "\\") {
      esc = true;
      continue;
    }
    if (q) {
      if (ch === q) q = null;
      else cur += ch;
      continue;
    }
    if (ch === "'" || ch === '"') {
      q = ch;
      continue;
    }
    if (/\s/.test(ch)) {
      if (cur.length) out.push(cur), (cur = "");
      continue;
    }
    cur += ch;
  }
  if (cur.length) out.push(cur);
  return out;
}

// ---------- pyproject parsing ----------

async function readUvScripts(workspaceFolder: string): Promise<EntryPoint[]> {
  const pyprojectPath = path.join(workspaceFolder, "pyproject.toml");
  const raw = await fs.readFile(pyprojectPath, "utf8");
  const doc = TOML.parse(raw) as any;

  const scripts: Record<string, string> = doc?.project?.scripts ?? {};
  const guiScripts: Record<string, string> = doc?.project?.["gui-scripts"] ?? {};

  const entries: EntryPoint[] = [];
  for (const [name, target] of Object.entries({ ...scripts, ...guiScripts })) {
    if (typeof target !== "string") continue;
    const parts = splitEntryPoint(target);
    if (!parts) continue;
    entries.push({ name, target, module: parts.module, func: parts.func });
  }

  return entries.sort((a, b) => a.name.localeCompare(b.name));
}

async function ensureWrapper(workspaceFolder: string, ep: EntryPoint): Promise<string> {
  const vscodeDir = path.join(workspaceFolder, ".vscode");
  await fs.mkdir(vscodeDir, { recursive: true });

  const wrapperPath = path.join(vscodeDir, ".uv_debug_entry.py");
  const code = `# Auto-generated by UV Debug Scripts
import importlib

MOD = ${JSON.stringify(ep.module)}
FN = ${JSON.stringify(ep.func)}

def _run():
    m = importlib.import_module(MOD)
    f = getattr(m, FN)
    return f()

if __name__ == "__main__":
    raise SystemExit(_run())
`;

  await fs.writeFile(wrapperPath, code, "utf8");
  return wrapperPath;
}

async function resolvePythonPath(workspaceFolder: string): Promise<string | undefined> {
  const isWin = process.platform === "win32";
  const candidate = isWin
    ? path.join(workspaceFolder, ".venv", "Scripts", "python.exe")
    : path.join(workspaceFolder, ".venv", "bin", "python");

  if (await fileExists(candidate)) return candidate;
  return undefined; // let VS Code / Python extension decide
}

// ---------- debug launching ----------

async function startDebug(
  wf: vscode.WorkspaceFolder,
  ep: EntryPoint,
  argsLine: string
): Promise<void> {
  const root = wf.uri.fsPath;

  // If there is no .venv, we still *can* try to debug (fallback interpreter),
  // but the UX is clearer if we warn.
  if (!(await hasVenv(root))) {
    vscode.window.showWarningMessage(
      `No .venv found for "${wf.name}". Debug may fail. Create it first (e.g., run 'uv sync').`
    );
  }

  const wrapper = await ensureWrapper(root, ep);
  const pythonPath = await resolvePythonPath(root);

  const cfg: vscode.DebugConfiguration = {
    type: "python",
    request: "launch",
    name: `uv: ${wf.name}/${ep.name}`,
    program: wrapper,
    args: parseArgs(argsLine),
    console: "integratedTerminal",
    justMyCode: true,
    cwd: root,
    env: { PYTHONPATH: root },
    ...(pythonPath ? { python: pythonPath } : {})
  };

  const ok = await vscode.debug.startDebugging(wf, cfg);
  if (!ok) throw new Error("Failed to start debugging session.");
}

// ---------- status UI ----------

function renderMainStatus(status: vscode.StatusBarItem, last: LastRun | undefined): void {
  if (!last) {
    status.text = "$(play) uv";
    status.tooltip = "UV: pick a script and debug it";
    status.command = `${EXT_NS}.debugScript`;
  } else {
    status.text = `$(debug-alt) uv`;
    status.tooltip = `Debug last script\n${last.scriptName}\nArgs: ${last.argsLine || "(none)"}`;
    status.command = `${EXT_NS}.debugLastScript`;
  }
  status.show();
}

function renderModeStatus(modeStatus: vscode.StatusBarItem): void {
  const hideUninit = vscode.workspace
    .getConfiguration(EXT_NS)
    .get<boolean>("hideUninitializedProjects", false);

  if (hideUninit) {
    modeStatus.text = "$(eye-closed)";
    modeStatus.tooltip = "Hiding uninitialized uv projects (.venv missing). Click to show all.";
  } else {
    modeStatus.text = "$(eye)";
    modeStatus.tooltip = "Showing all uv projects. Click to hide uninitialized.";
  }

  modeStatus.command = `${EXT_NS}.toggleHideUninitializedProjects`;
  modeStatus.show();
}

// ---------- per-workspace script cache ----------

function createScriptCache() {
  type CacheEntry = {
    scripts: EntryPoint[];
    lastError: string | null;
    refreshInFlight: Promise<void> | null;
  };

  const byRoot = new Map<string, CacheEntry>();

  function ensure(root: string): CacheEntry {
    const existing = byRoot.get(root);
    if (existing) return existing;
    const created: CacheEntry = { scripts: [], lastError: null, refreshInFlight: null };
    byRoot.set(root, created);
    return created;
  }

  const get = (root: string) => ensure(root).scripts;
  const getError = (root: string) => ensure(root).lastError;

  const refresh = async (root: string) => {
    const entry = ensure(root);
    if (entry.refreshInFlight) return entry.refreshInFlight;

    entry.refreshInFlight = (async () => {
      try {
        entry.scripts = await readUvScripts(root);
        entry.lastError = null;
      } catch (e: any) {
        entry.lastError = e?.message ?? String(e);
        entry.scripts = [];
      } finally {
        entry.refreshInFlight = null;
      }
    })();

    return entry.refreshInFlight;
  };

  return { get, getError, refresh };
}

// ---------- workspace picking ----------

async function pickWorkspaceFolderWithDefault(
  context: vscode.ExtensionContext,
  forcePick: boolean
): Promise<{ wf: vscode.WorkspaceFolder; root: string } | undefined> {
  const wfs = vscode.workspace.workspaceFolders ?? [];
  if (wfs.length === 0) {
    vscode.window.showErrorMessage("Open a folder/workspace first.");
    return undefined;
  }
  if (wfs.length === 1) {
    const wf = wfs[0];
    return { wf, root: wf.uri.fsPath };
  }

  const hideUninit = vscode.workspace
    .getConfiguration(EXT_NS)
    .get<boolean>("hideUninitializedProjects", false);

  const lastId = context.workspaceState.get<string>(LAST_WF_KEY);
  const last = wfFromKey(lastId);

  if (!forcePick && last) {
    return { wf: last, root: last.uri.fsPath };
  }

  let items = await Promise.all(
    wfs.map(async (wf) => {
      const root = wf.uri.fsPath;
      const ready = await hasVenv(root);
      return {
        label: ready ? `$(check) ${wf.name}` : `$(warning) ${wf.name}`,
        description: root,
        detail: ready ? "uv ready (.venv found)" : "uv uninitialized (.venv missing)",
        wf,
        root,
        ready
      };
    })
  );

  if (hideUninit) {
    items = items.filter((x) => x.ready);
  }

  if (items.length === 0) {
    vscode.window.showWarningMessage(
      hideUninit
        ? "No initialized uv projects found (.venv missing in all folders). Toggle the eye to show all."
        : "No workspace folders available."
    );
    return undefined;
  }

  const picked = await vscode.window.showQuickPick(items, { title: "UV: Which project?" });
  if (!picked) return undefined;

  await context.workspaceState.update(LAST_WF_KEY, workspaceKey(picked.wf));
  return { wf: picked.wf, root: picked.root };
}

// ---------- last-run storage (per-workspace-folder) ----------

function lastRunKeyFor(wf: vscode.WorkspaceFolder): string {
  return LAST_RUN_KEY_PREFIX + workspaceKey(wf);
}

async function setLastRun(
  context: vscode.ExtensionContext,
  status: vscode.StatusBarItem,
  wf: vscode.WorkspaceFolder,
  last: LastRun
): Promise<void> {
  await context.workspaceState.update(lastRunKeyFor(wf), last);
  // Keep main pill simple: it indicates last-run exists (per current active wf selection)
  renderMainStatus(status, last);
}

// ---------- commands ----------

async function pickAndDebug(
  context: vscode.ExtensionContext,
  status: vscode.StatusBarItem,
  cache: ReturnType<typeof createScriptCache>
): Promise<void> {
  // Force-pick workspace for this command so you can switch projects.
  const pickedWf = await pickWorkspaceFolderWithDefault(context, true);
  if (!pickedWf) return;

  const { wf, root } = pickedWf;

  await context.workspaceState.update(LAST_WF_KEY, workspaceKey(wf));

  // refresh scripts for that root
  await cache.refresh(root);

  const scripts = cache.get(root);
  if (!scripts.length) {
    const err = cache.getError(root);
    vscode.window.showWarningMessage(
      err
        ? `Failed to parse scripts for "${wf.name}": ${err}`
        : `No [project.scripts] or [project.gui-scripts] found for "${wf.name}".`
    );
    return;
  }

  const picked = await vscode.window.showQuickPick(
    scripts.map((s) => ({ label: s.name, description: s.target, s })),
    { title: `UV: Debug which script? (${wf.name})` }
  );
  if (!picked) return;

  const argsLine = await vscode.window.showInputBox({
    title: `Args for ${wf.name}/${picked.s.name}`,
    prompt: "Optional arguments (e.g. --foo 1 --bar \"hi\")",
    placeHolder: ""
  });
  if (argsLine === undefined) return;

  await startDebug(wf, picked.s, argsLine);
  await setLastRun(context, status, wf, {
    scriptName: picked.s.name,
    target: picked.s.target,
    argsLine
  });
}

async function debugLastInternal(
  context: vscode.ExtensionContext,
  status: vscode.StatusBarItem,
  cache: ReturnType<typeof createScriptCache>,
  mode: "fast" | "editArgs"
): Promise<void> {
  // Do NOT force-pick: status bar should be frictionless and use last workspace if possible
  const pickedWf = await pickWorkspaceFolderWithDefault(context, false);
  if (!pickedWf) return;

  const { wf, root } = pickedWf;

  const last = context.workspaceState.get<LastRun>(lastRunKeyFor(wf));
  if (!last) {
    // If no last for that workspace, fall back to interactive flow
    await pickAndDebug(context, status, cache);
    return;
  }

  await cache.refresh(root);
  const scripts = cache.get(root);

  const ep = scripts.find((s) => s.name === last.scriptName && s.target === last.target);
  if (!ep) {
    vscode.window.showWarningMessage(
      `Last script not found in "${wf.name}" pyproject.toml: ${last.scriptName} = ${last.target}`
    );
    await pickAndDebug(context, status, cache);
    return;
  }

  // Fast mode: if last args are empty, run immediately.
  if (mode === "fast" && (last.argsLine ?? "").trim() === "") {
    await startDebug(wf, ep, "");
    renderMainStatus(status, last);
    return;
  }

  const argsLine = await vscode.window.showInputBox({
    title: `Args for ${wf.name}/${ep.name}`,
    prompt: "Enter args (edit or reuse last)",
    value: last.argsLine
  });
  if (argsLine === undefined) return;

  await startDebug(wf, ep, argsLine);
  await setLastRun(context, status, wf, {
    scriptName: ep.name,
    target: ep.target,
    argsLine
  });
}

// ---------- activate/deactivate ----------

export function activate(context: vscode.ExtensionContext) {
  const mainStatus = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left, 100);
  const modeStatus = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left, 99);
  context.subscriptions.push(mainStatus, modeStatus);

  const cache = createScriptCache();

  // initial render
  const wf0 = vscode.workspace.workspaceFolders?.[0];
  const last0 = wf0 ? context.workspaceState.get<LastRun>(lastRunKeyFor(wf0)) : undefined;
  renderMainStatus(mainStatus, last0);
  renderModeStatus(modeStatus);

  // keep mode pill in sync with config changes
  context.subscriptions.push(
    vscode.workspace.onDidChangeConfiguration((e) => {
      if (e.affectsConfiguration(`${EXT_NS}.hideUninitializedProjects`)) {
        renderModeStatus(modeStatus);
      }
    })
  );

  // refresh caches when pyproject changes (multi-root)
  const pyprojectWatcher = vscode.workspace.createFileSystemWatcher("**/pyproject.toml");
  context.subscriptions.push(pyprojectWatcher);

  const refreshAll = async () => {
    const wfs = vscode.workspace.workspaceFolders ?? [];
    await Promise.all(wfs.map((wf) => cache.refresh(wf.uri.fsPath)));
  };

  pyprojectWatcher.onDidChange(() => refreshAll().catch(() => {}), null, context.subscriptions);
  pyprojectWatcher.onDidCreate(() => refreshAll().catch(() => {}), null, context.subscriptions);
  pyprojectWatcher.onDidDelete(() => refreshAll().catch(() => {}), null, context.subscriptions);

  // Commands
  context.subscriptions.push(
    vscode.commands.registerCommand(`${EXT_NS}.debugScript`, async () => {
      try {
        await pickAndDebug(context, mainStatus, cache);
      } catch (e: any) {
        vscode.window.showErrorMessage(e?.message ?? String(e));
      }
    })
  );

  context.subscriptions.push(
    vscode.commands.registerCommand(`${EXT_NS}.debugLastScript`, async () => {
      try {
        await debugLastInternal(context, mainStatus, cache, "fast");
      } catch (e: any) {
        vscode.window.showErrorMessage(e?.message ?? String(e));
      }
    })
  );

  context.subscriptions.push(
    vscode.commands.registerCommand(`${EXT_NS}.debugLastScriptEditArgs`, async () => {
      try {
        await debugLastInternal(context, mainStatus, cache, "editArgs");
      } catch (e: any) {
        vscode.window.showErrorMessage(e?.message ?? String(e));
      }
    })
  );

  // Eye toggle: store PER-WORKSPACE
  context.subscriptions.push(
    vscode.commands.registerCommand(`${EXT_NS}.toggleHideUninitializedProjects`, async () => {
      const cfg = vscode.workspace.getConfiguration(EXT_NS);
      const cur = cfg.get<boolean>("hideUninitializedProjects", false);

      await cfg.update(
        "hideUninitializedProjects",
        !cur,
        vscode.ConfigurationTarget.Workspace
      );

      renderModeStatus(modeStatus);
    })
  );
}

export function deactivate() {}