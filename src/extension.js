"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.activate = activate;
exports.deactivate = deactivate;
const vscode = __importStar(require("vscode"));
const path = __importStar(require("path"));
const fs = __importStar(require("fs/promises"));
const TOML = __importStar(require("@iarna/toml"));
const EXT_NS = "uvDebugScripts";
const LAST_RUN_KEY = "lastRun";
function splitEntryPoint(target) {
    const idx = target.lastIndexOf(":");
    if (idx <= 0 || idx === target.length - 1)
        return null;
    return { module: target.slice(0, idx), func: target.slice(idx + 1) };
}
async function fileExists(p) {
    try {
        await fs.stat(p);
        return true;
    }
    catch {
        return false;
    }
}
function parseArgs(argLine) {
    const out = [];
    let cur = "";
    let q = null;
    let esc = false;
    for (const ch of argLine) {
        if (esc) {
            cur += ch;
            esc = false;
            continue;
        }
        if (ch === "\\") {
            esc = true;
            continue;
        }
        if (q) {
            if (ch === q)
                q = null;
            else
                cur += ch;
            continue;
        }
        if (ch === "'" || ch === '"') {
            q = ch;
            continue;
        }
        if (/\s/.test(ch)) {
            if (cur.length)
                out.push(cur), (cur = "");
            continue;
        }
        cur += ch;
    }
    if (cur.length)
        out.push(cur);
    return out;
}
function getWorkspaceFolderOrThrow() {
    const wf = vscode.workspace.workspaceFolders?.[0];
    if (!wf)
        throw new Error("Open a folder/workspace first.");
    return wf;
}
async function readUvScripts(workspaceFolder) {
    const pyprojectPath = path.join(workspaceFolder, "pyproject.toml");
    const raw = await fs.readFile(pyprojectPath, "utf8");
    const doc = TOML.parse(raw);
    const scripts = doc?.project?.scripts ?? {};
    const guiScripts = doc?.project?.["gui-scripts"] ?? {};
    const entries = [];
    for (const [name, target] of Object.entries({ ...scripts, ...guiScripts })) {
        if (typeof target !== "string")
            continue;
        const parts = splitEntryPoint(target);
        if (!parts)
            continue;
        entries.push({ name, target, module: parts.module, func: parts.func });
    }
    return entries.sort((a, b) => a.name.localeCompare(b.name));
}
async function ensureWrapper(workspaceFolder, ep) {
    const vscodeDir = path.join(workspaceFolder, ".vscode");
    await fs.mkdir(vscodeDir, { recursive: true });
    const wrapperPath = path.join(vscodeDir, ".uv_debug_entry.py");
    const code = `# Auto-generated by UV Debug Scripts
import importlib

MOD = ${JSON.stringify(ep.module)}
FN = ${JSON.stringify(ep.func)}

def _run():
    m = importlib.import_module(MOD)
    f = getattr(m, FN)
    return f()

if __name__ == "__main__":
    raise SystemExit(_run())
`;
    await fs.writeFile(wrapperPath, code, "utf8");
    return wrapperPath;
}
async function resolvePythonPath(workspaceFolder) {
    const isWin = process.platform === "win32";
    const candidate = isWin
        ? path.join(workspaceFolder, ".venv", "Scripts", "python.exe")
        : path.join(workspaceFolder, ".venv", "bin", "python");
    if (await fileExists(candidate))
        return candidate;
    return undefined; // let Python extension / VS Code decide
}
async function startDebug(wf, ep, argsLine) {
    const root = wf.uri.fsPath;
    const wrapper = await ensureWrapper(root, ep);
    const pythonPath = await resolvePythonPath(root);
    const cfg = {
        type: "python",
        request: "launch",
        name: `uv: ${ep.name}`,
        program: wrapper,
        args: parseArgs(argsLine),
        console: "integratedTerminal",
        justMyCode: true,
        ...(pythonPath ? { python: pythonPath } : {})
    };
    const ok = await vscode.debug.startDebugging(wf, cfg);
    if (!ok)
        throw new Error("Failed to start debugging session.");
}
function renderStatusBar(status, last) {
    if (!last) {
        status.text = "$(play) uv: pick script";
        status.tooltip = "Pick a uv [project.scripts] entry and debug it";
        status.command = `${EXT_NS}.debugScript`;
    }
    else {
        status.text = `$(debug-alt) uv: ${last.scriptName}`;
        status.tooltip = `Debug last: ${last.scriptName}\nArgs: ${last.argsLine || "(none)"}`;
        status.command = `${EXT_NS}.debugLastScript`;
    }
    status.show();
}
async function setLastRun(context, status, last) {
    await context.workspaceState.update(LAST_RUN_KEY, last);
    renderStatusBar(status, last);
}
async function pickAndDebug(context, status) {
    const wf = getWorkspaceFolderOrThrow();
    const root = wf.uri.fsPath;
    const scripts = await readUvScripts(root);
    if (!scripts.length) {
        vscode.window.showWarningMessage("No [project.scripts] or [project.gui-scripts] found in pyproject.toml.");
        return;
    }
    const picked = await vscode.window.showQuickPick(scripts.map((s) => ({ label: s.name, description: s.target, s })), { title: "UV: Debug which script?" });
    if (!picked)
        return;
    const argsLine = await vscode.window.showInputBox({
        title: `Args for ${picked.s.name}`,
        prompt: "Optional arguments (e.g. --foo 1 --bar \"hi\")",
        placeHolder: ""
    });
    if (argsLine === undefined)
        return;
    await startDebug(wf, picked.s, argsLine);
    await setLastRun(context, status, {
        scriptName: picked.s.name,
        target: picked.s.target,
        argsLine
    });
}
async function debugLast(context, status) {
    const wf = getWorkspaceFolderOrThrow();
    const root = wf.uri.fsPath;
    const last = context.workspaceState.get(LAST_RUN_KEY);
    if (!last) {
        // Button behavior: if no last, act like “pick”
        await pickAndDebug(context, status);
        return;
    }
    const scripts = await readUvScripts(root);
    const ep = scripts.find((s) => s.name === last.scriptName && s.target === last.target);
    if (!ep) {
        vscode.window.showWarningMessage(`Last script not found in pyproject.toml: ${last.scriptName} = ${last.target}`);
        await pickAndDebug(context, status);
        return;
    }
    const argsLine = await vscode.window.showInputBox({
        title: `Args for ${ep.name}`,
        prompt: "Enter args (edit or reuse last)",
        value: last.argsLine
    });
    if (argsLine === undefined)
        return;
    await startDebug(wf, ep, argsLine);
    await setLastRun(context, status, {
        scriptName: ep.name,
        target: ep.target,
        argsLine
    });
}
function activate(context) {
    const status = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left, 100);
    context.subscriptions.push(status);
    // Initialize status bar immediately
    const last = context.workspaceState.get(LAST_RUN_KEY);
    renderStatusBar(status, last);
    // Optional nicety: if pyproject changes, keep status bar visible and sane
    const pyprojectWatcher = vscode.workspace.createFileSystemWatcher("**/pyproject.toml");
    context.subscriptions.push(pyprojectWatcher);
    const refresh = () => {
        const l = context.workspaceState.get(LAST_RUN_KEY);
        renderStatusBar(status, l);
    };
    pyprojectWatcher.onDidChange(refresh, null, context.subscriptions);
    pyprojectWatcher.onDidCreate(refresh, null, context.subscriptions);
    pyprojectWatcher.onDidDelete(refresh, null, context.subscriptions);
    context.subscriptions.push(vscode.commands.registerCommand(`${EXT_NS}.debugScript`, async () => {
        try {
            await pickAndDebug(context, status);
        }
        catch (e) {
            vscode.window.showErrorMessage(e?.message ?? String(e));
        }
    }));
    context.subscriptions.push(vscode.commands.registerCommand(`${EXT_NS}.debugLastScript`, async () => {
        try {
            await debugLast(context, status);
        }
        catch (e) {
            vscode.window.showErrorMessage(e?.message ?? String(e));
        }
    }));
}
function deactivate() { }
//# sourceMappingURL=extension.js.map